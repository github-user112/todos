<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é‡å¤äº‹ä»¶åŠŸèƒ½æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f7fa;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2d3748;
            text-align: center;
        }
        .test-button {
            background: #4a6cf7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        .test-button:hover {
            background: #3a5bd9;
        }
        #output {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 15px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 600px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .success {
            color: #48bb78;
        }
        .error {
            color: #f56565;
        }
        .info {
            color: #4299e1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>é‡å¤äº‹ä»¶åŠŸèƒ½æµ‹è¯•</h1>
        
        <div>
            <button class="test-button" onclick="runRepeatTests()">è¿è¡Œé‡å¤é€»è¾‘æµ‹è¯•</button>
            <button class="test-button" onclick="runValidationTests()">è¿è¡ŒéªŒè¯æµ‹è¯•</button>
            <button class="test-button" onclick="runPreviewTests()">è¿è¡Œé¢„è§ˆåŠŸèƒ½æµ‹è¯•</button>
            <button class="test-button" onclick="clearOutput()">æ¸…ç©ºè¾“å‡º</button>
        </div>
        
        <div id="output"></div>
    </div>

    <script type="module">
        // é‡å¤äº‹ä»¶è®¡ç®—é€»è¾‘ï¼ˆä»repeatUtils.jså¤åˆ¶ï¼‰
        function shouldShowRepeatingTodo(todoDate, currentDate, repeatType, interval = 1) {
            if (currentDate < todoDate) {
                return false;
            }
            
            if (!repeatType || repeatType === 'none') {
                return false;
            }
            
            if (!Number.isInteger(interval) || interval < 1) {
                return false;
            }
            
            switch (repeatType) {
                case 'daily':
                    return shouldShowDailyInterval(todoDate, currentDate, interval);
                case 'weekly':
                    return shouldShowWeeklyInterval(todoDate, currentDate, interval);
                case 'monthly':
                    return shouldShowMonthlyInterval(todoDate, currentDate, interval);
                case 'yearly':
                    return shouldShowYearlyInterval(todoDate, currentDate, interval);
                default:
                    return false;
            }
        }

        function shouldShowDailyInterval(todoDate, currentDate, interval) {
            const dayDiff = Math.floor(
                (currentDate.getTime() - todoDate.getTime()) / (1000 * 60 * 60 * 24)
            );
            return dayDiff >= 0 && dayDiff % interval === 0;
        }

        function shouldShowWeeklyInterval(todoDate, currentDate, interval) {
            if (todoDate.getDay() !== currentDate.getDay()) {
                return false;
            }
            
            const weekDiff = Math.floor(
                (currentDate.getTime() - todoDate.getTime()) / (1000 * 60 * 60 * 24 * 7)
            );
            return weekDiff >= 0 && weekDiff % interval === 0;
        }

        function shouldShowMonthlyInterval(todoDate, currentDate, interval) {
            const adjustedCurrentDate = adjustMonthEndDate(
                todoDate, 
                currentDate.getFullYear(), 
                currentDate.getMonth()
            );
            
            if (adjustedCurrentDate.getDate() !== currentDate.getDate()) {
                return false;
            }
            
            const monthDiff = 
                (currentDate.getFullYear() - todoDate.getFullYear()) * 12 + 
                (currentDate.getMonth() - todoDate.getMonth());
            
            return monthDiff >= 0 && monthDiff % interval === 0;
        }

        function shouldShowYearlyInterval(todoDate, currentDate, interval) {
            if (todoDate.getMonth() !== currentDate.getMonth()) {
                return false;
            }
            
            const todoDay = todoDate.getDate();
            const currentDay = currentDate.getDate();
            
            if (todoDay === 29 && todoDate.getMonth() === 1) {
                const isCurrentLeapYear = isLeapYear(currentDate.getFullYear());
                if (!isCurrentLeapYear && currentDay === 28) {
                    // å…è®¸åœ¨éé—°å¹´çš„2æœˆ28æ—¥æ˜¾ç¤ºåŸæœ¬2æœˆ29æ—¥çš„äº‹ä»¶
                } else if (currentDay !== todoDay) {
                    return false;
                }
            } else if (todoDay !== currentDay) {
                return false;
            }
            
            const yearDiff = currentDate.getFullYear() - todoDate.getFullYear();
            return yearDiff >= 0 && yearDiff % interval === 0;
        }

        function adjustMonthEndDate(originalDate, targetYear, targetMonth) {
            const originalDay = originalDate.getDate();
            const daysInTargetMonth = new Date(targetYear, targetMonth + 1, 0).getDate();
            const adjustedDay = Math.min(originalDay, daysInTargetMonth);
            return new Date(targetYear, targetMonth, adjustedDay);
        }

        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        }

        function validateRepeatInterval(repeatType, interval) {
            const limits = {
                daily: { min: 1, max: 365, unit: 'å¤©' },
                weekly: { min: 1, max: 52, unit: 'å‘¨' },
                monthly: { min: 1, max: 12, unit: 'ä¸ªæœˆ' },
                yearly: { min: 1, max: 10, unit: 'å¹´' }
            };
            
            if (repeatType === 'none') {
                return { valid: true };
            }
            
            const limit = limits[repeatType];
            if (!limit) {
                return { valid: false, message: 'ä¸æ”¯æŒçš„é‡å¤ç±»å‹' };
            }
            
            if (!Number.isInteger(interval) || interval < limit.min || interval > limit.max) {
                return { 
                    valid: false, 
                    message: `é—´éš”å¿…é¡»åœ¨${limit.min}-${limit.max}${limit.unit}ä¹‹é—´` 
                };
            }
            
            return { valid: true };
        }

        // æµ‹è¯•ç”¨ä¾‹
        const testCases = [
            {
                name: 'æ¯2å¤©é‡å¤',
                todoDate: new Date('2024-01-01'),
                repeatType: 'daily',
                interval: 2,
                testDates: [
                    { date: new Date('2024-01-01'), expected: true },
                    { date: new Date('2024-01-02'), expected: false },
                    { date: new Date('2024-01-03'), expected: true },
                    { date: new Date('2024-01-04'), expected: false },
                    { date: new Date('2024-01-05'), expected: true },
                ]
            },
            {
                name: 'æ¯3å‘¨é‡å¤ï¼ˆå‘¨ä¸€ï¼‰',
                todoDate: new Date('2024-01-01'),
                repeatType: 'weekly',
                interval: 3,
                testDates: [
                    { date: new Date('2024-01-01'), expected: true },
                    { date: new Date('2024-01-08'), expected: false },
                    { date: new Date('2024-01-15'), expected: false },
                    { date: new Date('2024-01-22'), expected: true },
                ]
            },
            {
                name: 'æ¯2ä¸ªæœˆé‡å¤',
                todoDate: new Date('2024-01-15'),
                repeatType: 'monthly',
                interval: 2,
                testDates: [
                    { date: new Date('2024-01-15'), expected: true },
                    { date: new Date('2024-02-15'), expected: false },
                    { date: new Date('2024-03-15'), expected: true },
                    { date: new Date('2024-04-15'), expected: false },
                    { date: new Date('2024-05-15'), expected: true },
                ]
            }
        ];

        // å…¨å±€å‡½æ•°
        window.runRepeatTests = function() {
            let output = 'å¼€å§‹æµ‹è¯•é‡å¤äº‹ä»¶é—´éš”åŠŸèƒ½...\n\n';
            let totalTests = 0;
            let passedTests = 0;
            
            testCases.forEach(testCase => {
                output += `æµ‹è¯•: ${testCase.name}\n`;
                output += `åŸå§‹æ—¥æœŸ: ${testCase.todoDate.toDateString()}\n`;
                output += `é‡å¤ç±»å‹: ${testCase.repeatType}, é—´éš”: ${testCase.interval}\n`;
                
                testCase.testDates.forEach(test => {
                    totalTests++;
                    const result = shouldShowRepeatingTodo(
                        testCase.todoDate, 
                        test.date, 
                        testCase.repeatType, 
                        testCase.interval
                    );
                    
                    const passed = result === test.expected;
                    if (passed) {
                        passedTests++;
                        output += `  âœ“ ${test.date.toDateString()}: ${result} (é¢„æœŸ: ${test.expected})\n`;
                    } else {
                        output += `  âœ— ${test.date.toDateString()}: ${result} (é¢„æœŸ: ${test.expected})\n`;
                    }
                });
                
                output += '\n';
            });
            
            output += `æµ‹è¯•å®Œæˆ: ${passedTests}/${totalTests} é€šè¿‡\n`;
            output += `æˆåŠŸç‡: ${((passedTests / totalTests) * 100).toFixed(1)}%\n`;
            
            if (passedTests === totalTests) {
                output += 'ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼\n';
            } else {
                output += 'âŒ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦æ£€æŸ¥å®ç°\n';
            }
            
            appendOutput(output);
        };

        window.runValidationTests = function() {
            let output = 'æµ‹è¯•é—´éš”éªŒè¯åŠŸèƒ½...\n';
            
            const validationTests = [
                { type: 'daily', interval: 1, expected: true },
                { type: 'daily', interval: 365, expected: true },
                { type: 'daily', interval: 366, expected: false },
                { type: 'weekly', interval: 52, expected: true },
                { type: 'weekly', interval: 53, expected: false },
                { type: 'monthly', interval: 12, expected: true },
                { type: 'monthly', interval: 13, expected: false },
            ];
            
            let totalTests = 0;
            let passedTests = 0;
            
            validationTests.forEach(test => {
                totalTests++;
                const result = validateRepeatInterval(test.type, test.interval);
                const passed = result.valid === test.expected;
                
                if (passed) {
                    passedTests++;
                    output += `  âœ“ ${test.type}é—´éš”${test.interval}: ${result.valid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}\n`;
                } else {
                    output += `  âœ— ${test.type}é—´éš”${test.interval}: ${result.valid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'} (é¢„æœŸ: ${test.expected ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'})\n`;
                    if (!result.valid) {
                        output += `    é”™è¯¯ä¿¡æ¯: ${result.message}\n`;
                    }
                }
            });
            
            output += `\néªŒè¯æµ‹è¯•å®Œæˆ: ${passedTests}/${totalTests} é€šè¿‡\n`;
            appendOutput(output);
        };

        window.runPreviewTests = function() {
            let output = 'æµ‹è¯•é¢„è§ˆåŠŸèƒ½...\n';
            
            // æ¨¡æ‹Ÿé¢„è§ˆåŠŸèƒ½æµ‹è¯•
            const baseDate = new Date('2024-01-15');
            output += `åŸå§‹æ—¥æœŸ: ${baseDate.toDateString()}\n`;
            output += 'æµ‹è¯•ä¸åŒé‡å¤ç±»å‹çš„é¢„è§ˆ:\n\n';
            
            const previewTests = [
                { type: 'daily', interval: 3, desc: 'æ¯3å¤©' },
                { type: 'weekly', interval: 2, desc: 'æ¯2å‘¨' },
                { type: 'monthly', interval: 1, desc: 'æ¯æœˆ' },
                { type: 'yearly', interval: 2, desc: 'æ¯2å¹´' }
            ];
            
            previewTests.forEach(test => {
                output += `${test.desc}é‡å¤:\n`;
                for (let i = 1; i <= 3; i++) {
                    let nextDate;
                    switch (test.type) {
                        case 'daily':
                            nextDate = new Date(baseDate);
                            nextDate.setDate(baseDate.getDate() + (test.interval * i));
                            break;
                        case 'weekly':
                            nextDate = new Date(baseDate);
                            nextDate.setDate(baseDate.getDate() + (test.interval * 7 * i));
                            break;
                        case 'monthly':
                            nextDate = new Date(baseDate);
                            nextDate.setMonth(baseDate.getMonth() + (test.interval * i));
                            break;
                        case 'yearly':
                            nextDate = new Date(baseDate);
                            nextDate.setFullYear(baseDate.getFullYear() + (test.interval * i));
                            break;
                    }
                    if (nextDate) {
                        output += `  ${i}. ${nextDate.toDateString()}\n`;
                    }
                }
                output += '\n';
            });
            
            appendOutput(output);
        };

        window.clearOutput = function() {
            document.getElementById('output').innerHTML = '';
        };

        function appendOutput(text) {
            const output = document.getElementById('output');
            output.textContent += text + '\n';
            output.scrollTop = output.scrollHeight;
        }
    </script>
</body>
</html>